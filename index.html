<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>PPS AI Chat</title>
  <link rel="icon" href="favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="favicon.png">

  <!-- Markdown renderer + Sanitizer -->
  <script src="https://cdn.jsdelivr.net/npm/marked@12/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.9/dist/purify.min.js"></script>

  <style>
    :root{
      --bg:#f3f4f6; --brand:#003366; --brand-2:#0055aa; --text:#0f172a; --muted:#64748b;
      --bubble-user:#f1f5f9; --bubble-bot:#fff; --bubble-border:#e2e8f0;
      --radius:12px; --footer-h:64px;
      --ui-font: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                 Roboto, "Helvetica Neue", Arial, sans-serif,
                 "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
    }
    *{box-sizing:border-box}
    html,body{height:100%; margin:0; -webkit-text-size-adjust:100%}
    body{
      background:var(--bg); color:var(--text); font-family:var(--ui-font);
      display:flex; justify-content:center; align-items:stretch;
      min-height:100svh; overflow-x:hidden;
    }
    input, textarea, button { font-family: var(--ui-font); }
    .hidden{display:none!important}

    /* Login */
    .login-wrapper{
      width:100%; max-width:400px; background:#fff; padding:32px; border-radius:var(--radius);
      box-shadow:0 4px 14px rgba(0,0,0,.08); text-align:center; margin:16px;
    }
    .login-wrapper h2{ margin-bottom:16px; font-size:clamp(18px,4.5vw,24px); line-height:1.2 }
    .login-wrapper input{
      width:100%; padding:12px 14px; margin-bottom:8px; border:1px solid var(--bubble-border); border-radius:var(--radius);
      font-size:16px;
    }
    .login-wrapper small{display:block; color:var(--muted); font-size:12px; margin-bottom:12px}
    .login-wrapper button{
      width:100%; padding:12px 14px; border-radius:var(--radius);
      border:1px solid var(--brand); background:var(--brand); color:#fff; cursor:pointer; font-size:15px
    }
    .login-wrapper button:hover{background:var(--brand-2); border-color:var(--brand-2)}

    /* Chat wrapper */
    .chat-wrapper{
      width:100%; max-width:920px; height:100svh;
      background:#fff; border:1px solid var(--bubble-border); border-radius:var(--radius);
      display:flex; flex-direction:column; box-shadow:0 4px 14px rgba(0,0,0,.08);
      overflow:hidden; contain:layout size style;
    }
    header{
      position:sticky; top:0; z-index:5;
      display:flex; justify-content:space-between; align-items:center;
      padding:8px 12px; border-bottom:1px solid var(--bubble-border); background:#fff;
    }
    header .title{ text-align:center; flex:1 }
    header img{ height:clamp(32px,6vw,64px); width:auto; object-fit:contain; display:block; margin:0 auto 4px }
    header h1{ margin:0; font-size:clamp(16px,4.5vw,20px); font-weight:700 }
    header p{ margin:4px 0 0; font-size:clamp(13px,3.8vw,16px); color:#555 }

    /* Kebab menu 3 ch·∫•m + Sign out */
    header .controls{ display:flex; gap:10px; align-items:center }
    .kebab{ position:relative; display:inline-flex; align-items:center; justify-content:center;
      width:36px; height:36px; border-radius:999px; border:1px solid #e5e7eb; background:#fff; cursor:pointer; }
    .kebab:hover{ background:#f8fafc }
    .kebab svg{ width:18px; height:18px }
    .kebab-menu{
      position:absolute; top:44px; right:0; background:#fff; border:1px solid #e5e7eb; border-radius:8px;
      box-shadow:0 8px 20px rgba(0,0,0,.12); min-width:160px; padding:8px; display:none; z-index:10;
    }
    .kebab-menu.show{ display:block }
    .kebab-item{
      width:100%; text-align:left; background:#fff; border:1px solid transparent; border-radius:8px;
      padding:8px 10px; cursor:pointer; font-size:14px; color:#111827;
    }
    .kebab-item:hover{ background:#f3f4f6; }

    #chat{
      flex:1; overflow-y:auto; -webkit-overflow-scrolling:touch;
      padding:12px 16px; display:flex; flex-direction:column; gap:12px;
      scroll-behavior:smooth; background:#fff;
      padding-bottom:calc(var(--footer-h) + env(safe-area-inset-bottom,0px) + 12px);
      overscroll-behavior:contain;
    }
    #chat::-webkit-scrollbar{width:6px}
    #chat::-webkit-scrollbar-thumb{background:rgba(0,0,0,.2); border-radius:4px}
    #chat::-webkit-scrollbar-thumb:hover{background:rgba(0,0,0,.35)}

    .msg{ max-width:75%; padding:10px 14px; border-radius:var(--radius); line-height:1.6;
          word-wrap:break-word; white-space:normal; animation:fadeIn .18s ease;
          display:flex; align-items:flex-start; gap:10px; position:relative }
    .msg.assistant{ align-self:stretch; max-width:100%; background:var(--bubble-bot) }
    .msg.user{ align-self:flex-end; background:var(--bubble-user); justify-content:flex-end }
    .avatar{ width:28px; height:28px; border-radius:50%; flex-shrink:0 } /* UPDATED: b·ªè border ƒë·ªÉ h√≤a n·ªÅn */

    .content a{ color:#0ea5e9; text-decoration:underline }
    .content img{ max-width:100%; height:auto; border-radius:8px; border:1px solid var(--bubble-border); margin:8px 0 }

    /* UPDATED: h·ªó tr·ª£ video hi·ªÉn th·ªã ƒë·∫πp nh∆∞ ·∫£nh */
    .content video{
      max-width:100%; height:auto; border-radius:8px; border:1px solid var(--bubble-border); margin:8px 0;
      display:block;
    }

    .content table{ border-collapse:collapse; width:100%; margin:8px 0 }
    .content th,.content td{ border:1px solid var(--bubble-border); padding:6px 8px; text-align:left }
    .content code{ font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace }
    .content pre{ background:#f8fafc; border:1px solid var(--bubble-border); border-radius:8px; padding:10px; overflow:auto }

    /* UPDATED: Status ‚ÄúThinking‚Ä¶/Thought‚Äù (to h∆°n + nh·∫•p nh√°y) */
    .status-chip{
      position:absolute; left:42px; top:-12px;
      font-size:13px; color:var(--muted); user-select:none; pointer-events:none;
      display:inline-flex; gap:6px; align-items:center;
    }
    .pulse { animation:pulse 1.2s ease-in-out infinite }
    @keyframes pulse { 0%,100%{opacity:.35} 50%{opacity:1} }

    @keyframes fadeIn{ from{opacity:.0; transform:translateY(2px)} to{opacity:1; transform:translateY(0)} }

    footer{
      position:fixed; left:50%; transform:translateX(-50%);
      width:min(920px, 100%); bottom:0; z-index:6;
      border-top:1px solid var(--bubble-border); background:#fff;
      padding:8px 12px calc(8px + env(safe-area-inset-bottom,0px));
    }
    .footer-inner{ display:flex; gap:8px; align-items:flex-end; position:relative }
    #prompt{
      /* ch·ª´a ch·ªó cho n√∫t g·ª≠i tr√≤n 44px trong √¥ */
      flex:1; padding:12px 64px 12px 12px;
      border:1px solid var(--bubble-border); border-radius:12px;
      outline:none; font-size:16px;
      resize:none; overflow-y:hidden; line-height:1.5; min-height:48px; max-height:40vh;
      background:#fff;
    }
    #prompt::placeholder{ font-size:13px; color:#9aa4b2 }

    /* ·∫®n n√∫t Send c≈© (gi·ªØ DOM) */
    #sendBtn{ display:none !important; }

    /* UPDATED: n√∫t g·ª≠i tr√≤n ‚Äì canh gi·ªØa m√©p ph·∫£i */
    .inbox-send{
      position:absolute; right:12px; top:50%; transform:translateY(-50%); width:44px; height:44px;
      border-radius:999px; background:#000; color:#fff; border:1px solid #000;
      display:none; align-items:center; justify-content:center; cursor:pointer;
      box-shadow:0 2px 8px rgba(0,0,0,.10);
    }
    .inbox-send.show{ display:inline-flex }
    .inbox-send:disabled{ opacity:.5; cursor:not-allowed }
    .inbox-send svg{ width:22px; height:22px; display:block }

    #scrollBtn{
      position:fixed; bottom:88px; left:50%; transform:translateX(-50%);
      background:#fff; color:#000; border:1px solid #e5e7eb;
      border-radius:50%; width:48px; height:48px; cursor:pointer;
      box-shadow:0 2px 6px rgba(0,0,0,.15);
      display:flex; align-items:center; justify-content:center;
      opacity:0; visibility:hidden; transition:opacity .3s ease, visibility .3s ease;
      z-index:7;
    }
    #scrollBtn svg{ width:22px; height:22px; display:block }
    #scrollBtn.show{ opacity:1; visibility:visible }

    body.kbd-open{ overflow:hidden }
    @media (max-width:600px){
      .chat-wrapper{ max-width:100%; height:100svh; border-radius:0 }
      header img{ height:36px }
    }
  </style>
</head>
<body>

<!-- Login -->
<div id="login" class="login-wrapper">
  <h2>üîë Please Sign in</h2>
  <input id="accessInput" type="password" placeholder="Enter Access Code" />
  <small>Please enter the Access code provided by the admin</small>
  <button id="loginBtn">Enter</button>
  <p id="loginMsg" style="color:red; display:none; margin-top:8px;">Invalid Access Code</p>
</div>

<!-- Chat UI -->
<div id="chatUI" class="chat-wrapper hidden">
  <header>
    <div class="title">
      <img src="logo.png" alt="PPS Logo">
      <h1>Hi there! üëã</h1>
      <p>I am the AI Agent of PPS, here to support you 24/7</p>
    </div>
    <div class="controls">
      <div class="kebab" id="kebabBtn" aria-label="More">
        <svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
          <circle cx="6" cy="12" r="2"></circle>
          <circle cx="12" cy="12" r="2"></circle>
          <circle cx="18" cy="12" r="2"></circle>
        </svg>
        <div class="kebab-menu" id="kebabMenu">
          <button class="kebab-item" id="kebabSignOut">Sign out</button>
        </div>
      </div>
      <button class="signout hidden" id="signoutBtn">Sign out</button>
    </div>
  </header>

  <div id="chat"></div>

  <button id="scrollBtn" aria-label="Scroll to bottom" title="Scroll to bottom">
    <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
      <path d="M6 9l6 6 6-6" stroke="currentColor" stroke-width="1.75" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
  </button>

  <footer id="appFooter">
    <div class="footer-inner">
      <textarea id="prompt" rows="1" placeholder="Type to search, analyze, or request..."></textarea>
      <!-- N√∫t g·ª≠i tr√≤n trong √¥ nh·∫≠p -->
      <button id="inboxSend" class="inbox-send" title="Send" aria-label="Send">
        <svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M12 19V6"></path>
          <path d="M5 13l7-7 7 7"></path>
        </svg>
      </button>
      <button id="sendBtn">Send</button> <!-- gi·ªØ DOM, ·∫©n b·∫±ng CSS -->
    </div>
  </footer>
</div>

<script>
/* Footer resize, keyboard handling */
(function(){
  const footer=document.getElementById('appFooter');
  const chat=document.getElementById('chat');
  const wrap=document.querySelector('.chat-wrapper');
  function applyFooterHeight(){
    const h=footer?.offsetHeight||64;
    document.documentElement.style.setProperty('--footer-h',h+'px');
  }
  applyFooterHeight();
  window.addEventListener('resize',applyFooterHeight);
  if(footer&&'ResizeObserver'in window)new ResizeObserver(applyFooterHeight).observe(footer);
  function setViewportBindings(){
    if(!window.visualViewport)return;
    const vv=window.visualViewport;
    const setHeights=()=>{
      if(wrap)wrap.style.height=vv.height+'px';
      const kb=Math.max(0,(window.innerHeight-vv.height-vv.offsetTop));
      footer.style.bottom=kb+'px';
      if(kb>0)document.body.classList.add('kbd-open');else document.body.classList.remove('kbd-open');
      chat.scrollTop=chat.scrollHeight;
    };
    vv.addEventListener('resize',setHeights); vv.addEventListener('scroll',setHeights); setHeights();
  }
  setViewportBindings();
  const input=document.getElementById('prompt');
  input.addEventListener('focus',()=>{setTimeout(()=>{window.scrollTo(0,0);chat.scrollTop=chat.scrollHeight;},120)});
  input.addEventListener('blur',()=>{document.body.classList.remove('kbd-open');});
})();
</script>

<script>
/* Login */
const AUTO_LOGOUT_MS=30*60*1000;let inactivityTimer;
const accessEl=document.getElementById('accessInput');
const loginBtn=document.getElementById('loginBtn');
const loginBox=document.getElementById('login');
const chatBox=document.getElementById('chatUI');
const loginMsg=document.getElementById('loginMsg');
const signoutBtn=document.getElementById('signoutBtn');

const kebabBtn=document.getElementById('kebabBtn');
const kebabMenu=document.getElementById('kebabMenu');
const kebabSignOut=document.getElementById('kebabSignOut');

function resetInactivityTimer(){clearTimeout(inactivityTimer);inactivityTimer=setTimeout(()=>{alert("Session timed out.");signOut();},AUTO_LOGOUT_MS);}
function initInactivityListeners(){["click","keydown","mousemove","scroll","touchstart"].forEach(ev=>{document.addEventListener(ev,resetInactivityTimer,{passive:true});});resetInactivityTimer();}
async function checkAccess(){
  const val=accessEl.value.trim();if(!val){loginMsg.textContent='Please enter the Access code';loginMsg.style.display='block';return;}
  loginBtn.disabled=true;const oldLabel=loginBtn.textContent;loginBtn.textContent='Verifying...';loginMsg.style.display='none';
  try{
    const res=await fetch("/api/login",{method:"POST",headers:{"content-type":"application/json"},body:JSON.stringify({code:val})});
    if(res.ok){loginBox.classList.add('hidden');chatBox.classList.remove('hidden');initInactivityListeners();accessEl.value='';}
    else{let reason='Invalid Access Code';try{const j=await res.json();if(j?.error)reason=j.error;}catch{}loginMsg.textContent=reason;loginMsg.style.display='block';}
  }catch(e){loginMsg.textContent='Unable to connect. Please try again later.';loginMsg.style.display='block';}
  finally{loginBtn.disabled=false;loginBtn.textContent=oldLabel;}
}
loginBtn.addEventListener('click',checkAccess);
accessEl.addEventListener('keydown',e=>{if(e.key==='Enter'){e.preventDefault();checkAccess();}});
async function signOut(){
  try{await fetch("/api/logout",{method:"POST"});}catch{}
  chatBox.classList.add('hidden');loginBox.classList.remove('hidden');clearTimeout(inactivityTimer);
  localStorage.removeItem('ppsai_session_id');localStorage.removeItem('ppsai_messages');
  const chatEl=document.getElementById('chat');if(chatEl)chatEl.innerHTML='';
}
signoutBtn.addEventListener('click',signOut);
(async()=>{const r=await fetch("/api/session").catch(()=>null);if(r&&r.ok){loginBox.classList.add('hidden');chatBox.classList.remove('hidden');initInactivityListeners();}})();

kebabBtn?.addEventListener('click', (e)=>{ e.stopPropagation(); kebabMenu.classList.toggle('show'); });
document.addEventListener('click', (e)=>{ if(!kebabBtn.contains(e.target)) kebabMenu.classList.remove('show'); });
kebabSignOut?.addEventListener('click', ()=>{ kebabMenu.classList.remove('show'); signOut(); });
</script>

<script>
/* Chat + Streaming v·ªØng (UTF-8, SSE/NDJSON, throttle 33ms) */
const chatEl=document.getElementById('chat');
const inputEl=document.getElementById('prompt');
const btnEl=document.getElementById('sendBtn');

const SESSION_KEY='ppsai_session_id';
let sessionId=localStorage.getItem(SESSION_KEY);
if(!sessionId){
  sessionId=(crypto&&crypto.randomUUID)?crypto.randomUUID():Date.now().toString();
  localStorage.setItem(SESSION_KEY,sessionId);
}

/* L·ªãch s·ª≠ c√≥ TTL & gi·ªõi h·∫°n */
const MSGS_KEY='ppsai_messages';
const HISTORY_TTL_DAYS=30,HISTORY_MAX_ITEMS=200,HISTORY_MAX_BYTES=800000;
function loadMessages(){try{return JSON.parse(localStorage.getItem(MSGS_KEY)||'[]');}catch{return[]}}
function saveMessages(arr){
  const now=Date.now(),ttlMs=HISTORY_TTL_DAYS*24*60*60*1000;
  let pruned=arr.filter(m=>!m.ts||(now-m.ts)<=ttlMs);
  if(pruned.length>HISTORY_MAX_ITEMS)pruned=pruned.slice(pruned.length-HISTORY_MAX_ITEMS);
  let json=JSON.stringify(pruned);
  while(json.length>HISTORY_MAX_BYTES&&pruned.length>1){pruned.shift();json=JSON.stringify(pruned);}
  localStorage.setItem(MSGS_KEY,json);
}
let messages=loadMessages();renderHistory(messages);

/* N√∫t g·ª≠i tr√≤n trong √¥ nh·∫≠p (ch·ªâ hi·ªán khi c√≥ n·ªôi dung) */
const inboxSend=document.getElementById('inboxSend');
function toggleInboxSend(){
  const hasText=!!inputEl.value.trim();
  inboxSend.classList.toggle('show', hasText);
  inboxSend.disabled=!hasText;
}
inputEl.addEventListener('input', toggleInboxSend);
toggleInboxSend();

btnEl.addEventListener('click',onSend);
inboxSend.addEventListener('click',onSend);

/* Textarea: Enter g·ª≠i, Shift+Enter xu·ªëng d√≤ng + auto-resize */
inputEl.addEventListener('keydown',e=>{
  if(e.key==='Enter'&&!e.shiftKey){e.preventDefault();onSend();}
});
function autosizeTextarea(el){
  el.style.height='auto';
  const max=Math.round(window.innerHeight*0.40);
  const h=Math.min(el.scrollHeight,max);
  el.style.height=h+'px';
  el.style.overflowY=(el.scrollHeight>max)?'auto':'hidden';
}
inputEl.addEventListener('input',()=>autosizeTextarea(inputEl));
window.addEventListener('resize',()=>autosizeTextarea(inputEl));
autosizeTextarea(inputEl);

/* M·ªü link trong tab m·ªõi */
chatEl.addEventListener('click',e=>{
  const a=e.target.closest('a'); if(!a) return;
  const href=a.getAttribute('href'); if(!href||href.startsWith('#')) return;
  e.preventDefault(); a.setAttribute('rel','noopener'); a.setAttribute('target','_blank');
  try{ window.open(a.href,'_blank','noopener,noreferrer'); }catch{ a.click(); }
});

/* Markdown render */
marked.setOptions({gfm:true,breaks:true,headerIds:false,mangle:false});
function renderMarkdown(md){
  let html=marked.parse(md||'');
  html=html.replace(/<a /g,'<a target="_blank" rel="noopener" ');
  return DOMPurify.sanitize(html);
}

/* Status chip tr√™n c√πng icon AI */
function setStatusChip(targetNode, typeOrText){
  if(!targetNode) return;
  let chip=targetNode.querySelector('.status-chip');
  if(!chip){
    chip=document.createElement('div');
    chip.className='status-chip';
    targetNode.appendChild(chip);
  }
  if(typeOrText==='thinking'){
    chip.innerHTML = `<span class="pulse">Thinking‚Ä¶</span>`;
  }else if(typeOrText==='thought'){
    chip.innerHTML = `<span class="pulse">Thought</span>`;
  }else{
    chip.textContent='';
  }
}

/* appendBubble tr·∫£ v·ªÅ node ƒë·ªÉ stream c√≥ th·ªÉ c·∫≠p nh·∫≠t tr·ª±c ti·∫øp */
/* UPDATED: nh·∫≠n th√™m videoUrl v√† render <video> */
function appendBubble(text,role='assistant',imageUrl=null,videoUrl=null){
  const d=document.createElement('div');
  d.className='msg '+(role==='user'?'user':'assistant');

  if(role==='assistant'){
    const av=document.createElement('img'); 
    av.src="assistant_icon_256.png"; /* icon tr·ª£ l√Ω */
    av.alt="Assistant"; av.className="avatar";
    av.onerror=()=>{ av.replaceWith(document.createTextNode("ü§ñ")); };
    d.appendChild(av);
    const chip=document.createElement('div'); chip.className='status-chip'; chip.textContent='';
    d.appendChild(chip);
  }

  const content=document.createElement('div');
  content.className='content';
  content.innerHTML=renderMarkdown(text||'');
  d.appendChild(content);
  chatEl.appendChild(d);

  if(imageUrl){
    const w=document.createElement('div');
    w.className='content';
    w.innerHTML=`<a href="${encodeURI(imageUrl)}" target="_blank" rel="noopener">
      <img src="${encodeURI(imageUrl)}" alt="Image from AI">
    </a>`;
    chatEl.appendChild(w);
  }
  if(videoUrl){
    const v=document.createElement('div');
    v.className='content';
    const type = /\.webm$/i.test(videoUrl) ? 'video/webm' : 'video/mp4';
    v.innerHTML = `
      <video controls playsinline>
        <source src="${encodeURI(videoUrl)}" type="${type}">
        Your browser does not support the video tag.
      </video>`;
    chatEl.appendChild(v);
  }

  chatEl.scrollTop=chatEl.scrollHeight;
  return d;
}
function renderHistory(arr){
  chatEl.innerHTML='';
  const sorted=[...arr].sort((a,b)=>(a.ts||0)-(b.ts||0));
  sorted.forEach(m=>appendBubble(m.content,m.role,m.image_url, m.video_url));
}

/* ---------- UPDATED: Poll helper cho video long-running ---------- */
async function pollVideoUntilReady(opName, onDone, onProgress){
  const poll = async () => {
    try{
      const r = await fetch(`/api/media?op=${encodeURIComponent(opName)}`, { method:'GET' });
      const j = await r.json();
      if (!r.ok || !j.ok) throw new Error(j?.error||'poll_error');
      if (j.pending){
        onProgress && onProgress(j);
        setTimeout(poll, j.poll_after_ms || 5000);
      }else{
        onDone && onDone(j.video_url, null);
      }
    }catch(e){
      onDone && onDone(null, e);
    }
  };
  poll();
}

/* ---------- UPDATED: helper g·ªçi media khi ph√°t hi·ªán directive trong stream ---------- */
async function handleMediaDirective(media, targetNode){
  if(!media || !media.type || !media.prompt) return;

  const contentEl = targetNode.querySelector('.content');
  const old = contentEl.innerHTML;
  const waiting = media.type === 'image' ? 'üñºÔ∏è ƒêang t·∫°o ·∫£nh‚Ä¶' : 'üé¨ ƒêang t·∫°o video‚Ä¶';
  contentEl.innerHTML = renderMarkdown(`${old ? old+'\n\n' : ''}${waiting}`);

  try{
    const r = await fetch('/api/media', {
      method:'POST',
      headers:{'content-type':'application/json'},
      body: JSON.stringify({ type: media.type, prompt: media.prompt })
    });
    const j = await r.json();

    if(!r.ok || !j.ok){
      contentEl.innerHTML = renderMarkdown(`${old}\n\n‚ö†Ô∏è T·∫°o media l·ªói: ${j?.error||'unknown'}`);
      return;
    }

    if(j.image_url){
      const wrap=document.createElement('div');
      wrap.className='content';
      wrap.innerHTML = `<img src="${j.image_url}" alt="Generated image" style="max-width:100%;border-radius:12px;margin-top:8px">`;
      targetNode.appendChild(wrap);
    }else if(j.video_url){
      const wrap=document.createElement('div');
      wrap.className='content';
      const type = j.video_url.startsWith('data:video/webm') ? 'video/webm' : 'video/mp4';
      wrap.innerHTML = `<video controls playsinline style="max-width:100%;border-radius:12px;margin-top:8px">
                          <source src="${j.video_url}" type="${type}">
                        </video>`;
      targetNode.appendChild(wrap);
    }else if(j.pending && j.op_name){
      await new Promise((resolve)=>{
        pollVideoUntilReady(j.op_name, (videoUrl, err)=>{
          if(err || !videoUrl){
            contentEl.innerHTML = renderMarkdown(`${old}\n\n‚ö†Ô∏è T·∫°o video l·ªói.`);
            resolve(); return;
          }
          const wrap=document.createElement('div');
          wrap.className='content';
          const type = /\.webm$/i.test(videoUrl) ? 'video/webm' : 'video/mp4';
          wrap.innerHTML = `<video controls playsinline style="max-width:100%;border-radius:12px;margin-top:8px">
                              <source src="${videoUrl}" type="${type}">
                            </video>`;
          targetNode.appendChild(wrap);
          resolve();
        });
      });
    }

    const doneMsg = media.type==='image' ? 'üñºÔ∏è ƒê√£ t·∫°o ·∫£nh' : 'üé¨ ƒê√£ t·∫°o video';
    contentEl.innerHTML = renderMarkdown(`${old}\n\n${doneMsg}`);
    chatEl.scrollTop = chatEl.scrollHeight;

  }catch(e){
    contentEl.innerHTML = renderMarkdown(`‚ö†Ô∏è T·∫°o media l·ªói: ${String(e)}`);
  }
}

/* ========== STREAMING CORE (b·∫Øt _media trong SSE) ========== */
async function streamFromWebhook(sessionId,message,targetNode){
  const headers={
    'Content-Type':'application/json',
    'Accept':'text/event-stream, application/x-ndjson, application/json, text/plain; charset=utf-8'
  };
  const body=JSON.stringify({sessionId,chatInput:message});
  const tries=[
    {url:'/api/chat?stream=1',method:'POST'},
    {url:'/api/chat/stream',method:'POST'},
  ];
  let res=null;
  for(const t of tries){
    try{const r=await fetch(t.url,{method:t.method,headers,body}); if(r.ok){res=r;break;}}catch{}
  }
  if(!res){
    // Fallback non-stream m·ªôt l·∫ßn
    const result=await sendToWebhook(sessionId,message);
    if(!targetNode.querySelector('.content').innerHTML.trim()) setStatusChip(targetNode,'thought');
    targetNode.querySelector('.content').innerHTML=renderMarkdown(result.content||'(kh√¥ng c√≥ n·ªôi dung)');

    if(result.image_url){
      const w=document.createElement('div');w.className='content';
      w.innerHTML=`<a href="${encodeURI(result.image_url)}" target="_blank" rel="noopener"><img src="${encodeURI(result.image_url)}" alt="Image from AI"></a>`;
      chatEl.appendChild(w);
    }

    if(result.pending && result.op_name){
      const typing=document.createElement('div');
      typing.className='content typing';
      typing.textContent='Generating video‚Ä¶';
      targetNode.after(typing);

      await new Promise((resolve)=>{
        pollVideoUntilReady(result.op_name, (videoUrl, err)=>{
          typing.remove();
          if(err || !videoUrl){
            const eDiv=document.createElement('div'); eDiv.className='content'; eDiv.style.color='#b91c1c';
            eDiv.textContent='Video failed. Please try again.';
            chatEl.appendChild(eDiv);
            resolve();
            return;
          }
          const v=document.createElement('div'); v.className='content';
          const type = /\.webm$/i.test(videoUrl) ? 'video/webm' : 'video/mp4';
          v.innerHTML=`<video controls playsinline><source src="${encodeURI(videoUrl)}" type="${type}"></video>`;
          chatEl.appendChild(v);
          result.video_url = videoUrl;
          resolve();
        });
      });
    }
    return result;
  }

  // ---- ƒê·ªåC STREAM (SSE/NDJSON) ----
  const reader=res.body.getReader();
  const decoder=new TextDecoder('utf-8');
  let buffer=''; let acc=''; let started=false;

  let imageRendered=false, videoRendered=false;
  let lastImageUrl=null, lastVideoUrl=null;

  // throttle render 33ms
  let needs=false;
  const contentEl = targetNode.querySelector('.content');
  const schedule=()=>{
    if(needs) return;
    needs=true; setTimeout(()=>{
      contentEl.innerHTML = renderMarkdown(acc);
      chatEl.scrollTop = chatEl.scrollHeight;
      needs=false;
    },33);
  };

  setStatusChip(targetNode,'thinking');

  while(true){
    const {done,value}=await reader.read();
    if(value){ buffer += decoder.decode(value,{stream:!done}); }

    let pos=0, nl;
    while((nl = buffer.indexOf('\n', pos)) !== -1){
      const raw = buffer.slice(pos, nl);
      pos = nl + 1;

      let line = raw;
      if(!line) continue;

      if(/^\s*data\s*:/.test(line)) line = line.replace(/^\s*data\s*:\s?/, '');

      if(line[0]==='{' || line[0]==='['){
        try{
          const obj = JSON.parse(line);

          // UPDATED: b·∫Øt directive _media t·ª´ GPT (kh√¥ng render JSON ra UI)
          if (obj && obj._media && typeof obj._media === 'object') {
            handleMediaDirective(obj._media, targetNode);
            continue;
          }

          if(obj.type === 'begin' || obj.type === 'end') { /* skip */ }
          else{
            if(obj.pending && obj.op_name && !videoRendered){
              const typing=document.createElement('div');
              typing.className='content typing';
              typing.textContent='Generating video‚Ä¶';
              targetNode.after(typing);

              pollVideoUntilReady(obj.op_name, (videoUrl, err)=>{
                typing.remove();
                if(err || !videoUrl){
                  const eDiv=document.createElement('div'); eDiv.className='content'; eDiv.style.color='#b91c1c';
                  eDiv.textContent='Video failed. Please try again.';
                  chatEl.appendChild(eDiv);
                  return;
                }
                videoRendered=true;
                lastVideoUrl=videoUrl;
                const v=document.createElement('div'); v.className='content';
                const type = /\.webm$/i.test(videoUrl) ? 'video/webm' : 'video/mp4';
                v.innerHTML=`<video controls playsinline><source src="${encodeURI(videoUrl)}" type="${type}"></video>`;
                chatEl.appendChild(v);
              });
            }

            if(obj.image_url && !imageRendered){
              imageRendered=true; lastImageUrl=obj.image_url;
              const w=document.createElement('div'); w.className='content';
              w.innerHTML=`<a href="${encodeURI(obj.image_url)}" target="_blank" rel="noopener"><img src="${encodeURI(obj.image_url)}" alt="Image from AI"></a>`;
              chatEl.appendChild(w);
            }
            if(obj.video_url && !videoRendered){
              videoRendered=true; lastVideoUrl=obj.video_url;
              const v=document.createElement('div'); v.className='content';
              const type = /\.webm$/i.test(obj.video_url) ? 'video/webm' : 'video/mp4';
              v.innerHTML=`<video controls playsinline><source src="${encodeURI(obj.video_url)}" type="${type}"></video>`;
              chatEl.appendChild(v);
            }

            const chunk = pickContent(obj);
            if(chunk){
              if(!started){ setStatusChip(targetNode,'thought'); started=true; }
              acc += chunk;
              schedule();
            }
          }
          continue;
        }catch{
          // text th∆∞·ªùng: th·ª≠ b·∫Øt JSON _media inline
          try{
            const m = line.match(/\{[\s\S]*"_media"[\s\S]*\}/);
            if(m){
              const o = JSON.parse(m[0]);
              if(o && o._media){
                handleMediaDirective(o._media, targetNode);
                continue; // kh√¥ng render JSON ra UI
              }
            }
          }catch{}
        }
      }

      if(line.trim()){
        if(!started){ setStatusChip(targetNode,'thought'); started=true; }
        acc += line + '\n';
        schedule();
      }
    }
    buffer = buffer.slice(pos);
    if(done) break;
  }

  if(buffer.trim()){
    let line = buffer.replace(/^\s*data\s*:\s?/, '');
    try{
      const obj=JSON.parse(line);
      if(obj && obj._media && typeof obj._media === 'object'){
        handleMediaDirective(obj._media, targetNode);
      }else if(obj.type!=='begin' && obj.type!=='end'){
        if(obj.pending && obj.op_name && !videoRendered){
          const typing=document.createElement('div');
          typing.className='content typing';
          typing.textContent='Generating video‚Ä¶';
          targetNode.after(typing);
          pollVideoUntilReady(obj.op_name, (videoUrl, err)=>{
            typing.remove();
            if(err || !videoUrl){
              const eDiv=document.createElement('div'); eDiv.className='content'; eDiv.style.color='#b91c1c';
              eDiv.textContent='Video failed. Please try again.';
              chatEl.appendChild(eDiv);
              return;
            }
            videoRendered=true;
            lastVideoUrl=videoUrl;
            const v=document.createElement('div'); v.className='content';
            const type = /\.webm$/i.test(videoUrl) ? 'video/webm' : 'video/mp4';
            v.innerHTML=`<video controls playsinline><source src="${encodeURI(videoUrl)}" type="${type}"></video>`;
            chatEl.appendChild(v);
          });
        }
        if(obj.image_url && !imageRendered){
          imageRendered=true; lastImageUrl=obj.image_url;
          const w=document.createElement('div'); w.className='content';
          w.innerHTML=`<a href="${encodeURI(obj.image_url)}" target="_blank" rel="noopener"><img src="${encodeURI(obj.image_url)}" alt="Image from AI"></a>`;
          chatEl.appendChild(w);
        }
        if(obj.video_url && !videoRendered){
          videoRendered=true; lastVideoUrl=obj.video_url;
          const v=document.createElement('div'); v.className='content';
          const type = /\.webm$/i.test(obj.video_url) ? 'video/webm' : 'video/mp4';
          v.innerHTML=`<video controls playsinline><source src="${encodeURI(obj.video_url)}" type="${type}"></video>`;
          chatEl.appendChild(v);
        }
        const chunk=pickContent(obj);
        if(chunk){ acc+=chunk; }
      }
    }catch{
      // C√≥ th·ªÉ l√† text th∆∞·ªùng
      try{
        const m = line.match(/\{[\s\S]*"_media"[\s\S]*\}/);
        if(m){
          const o = JSON.parse(m[0]);
          if(o && o._media) handleMediaDirective(o._media, targetNode);
        }else{
          acc+=line+'\n';
        }
      }catch{
        acc+=line+'\n';
      }
    }
    contentEl.innerHTML = renderMarkdown(acc);
  }

  setTimeout(()=>setStatusChip(targetNode,''),800);
  return { content: acc, image_url: lastImageUrl, video_url: lastVideoUrl };

  function pickContent(obj){
    if(typeof obj.delta === 'string') return obj.delta;
    if(typeof obj.content === 'string') return obj.content;
    if(typeof obj.output  === 'string') return obj.output;
    if(obj.item && typeof obj.item.content === 'string') return obj.item.content;
    if(obj.data && typeof obj.data.text === 'string') return obj.data.text;
    if(typeof obj.text === 'string') return obj.text;
    return '';
  }
}

/* G·ª≠i */
async function onSend(){
  const text=inputEl.value.trim(); if(!text) return;

  appendBubble(text,'user');
  messages.push({role:'user',content:text,ts:Date.now()}); saveMessages(messages);

  inputEl.value=''; autosizeTextarea(inputEl);
  toggleInboxSend();

  const node=appendBubble('','assistant'); // placeholder
  setStatusChip(node,'thinking');

  try{
    const result=await streamFromWebhook(sessionId,text,node);
    const finalText = (typeof result==='string') ? result : (result?.content||'');
    const img = result && result.image_url ? result.image_url : null;
    const vid = result && result.video_url ? result.video_url : null;

    if(result && result.pending && result.op_name){
      const typing=document.createElement('div');
      typing.className='content typing';
      typing.textContent='Generating video‚Ä¶';
      node.after(typing);

      await new Promise((resolve)=>{
        pollVideoUntilReady(result.op_name, (videoUrl, err)=>{
          typing.remove();
          if(!err && videoUrl){
            const v=document.createElement('div'); v.className='content';
            const type = /\.webm$/i.test(videoUrl) ? 'video/webm' : 'video/mp4';
            v.innerHTML=`<video controls playsinline><source src="${encodeURI(videoUrl)}" type="${type}"></video>`;
            chatEl.appendChild(v);
            messages.push({role:'assistant',content:'',image_url:null,video_url:videoUrl,ts:Date.now()});
            saveMessages(messages);
          }
          resolve();
        });
      });
    }

    messages.push({role:'assistant',content:finalText,image_url:img,video_url:vid,ts:Date.now()});
    saveMessages(messages);
  }catch(err){
    const msg=`Error (stream): ${String(err)}`;
    node.querySelector('.content').innerHTML=renderMarkdown(msg);
    messages.push({role:'assistant',content:msg,image_url:null,video_url:null,ts:Date.now()});
    saveMessages(messages);
  }finally{
    setTimeout(()=>setStatusChip(node,''), 800);
  }
}

/* NON-STREAM fallback (gom NDJSON/text, b·∫Øt pending/op_name) */
async function sendToWebhook(sessionId,message){
  const headers={'Content-Type':'application/json','Accept':'application/json, text/plain, application/x-ndjson; charset=utf-8'};
  const res=await fetch("/api/chat",{method:'POST',headers,body:JSON.stringify({sessionId,chatInput:message})});
  if(!res.ok){
    const t=await res.text().catch(()=> '');
    throw new Error(`${res.status} ${t.slice(0,200)}`);
  }
  const ct=(res.headers.get('content-type')||'').toLowerCase();

  if(ct.includes('application/json')){
    try{
      const data=await res.json();
      let content=null,image_url=null,video_url=null,pending=false,op_name=null;
      if(Array.isArray(data)){
        const f=data[0]||{};
        content=f.content||f.output||'';
        image_url=f.image_url||f.url||null;
        video_url=f.video_url||null;
        pending=!!f.pending; op_name=f.op_name||null;
      }else{
        content=data.content||data.output||'';
        image_url=data.image_url||data.url||null;
        video_url=data.video_url||null;
        pending=!!data.pending; op_name=data.op_name||null;
      }
      return {content,image_url,video_url,pending,op_name};
    }catch{ /* r∆°i xu·ªëng text */ }
  }

  const text=await res.text();
  const parsed = renderStreamLikeText(text, null, false);
  return parsed;
}

/* Gom NDJSON/text, b·∫Øt image_url/video_url + pending/op_name */
function renderStreamLikeText(text, targetNode=null, markThought=false){
  const lines=text.split(/\r?\n/);
  let acc=''; let img=null; let vid=null; let pending=false; let op_name=null;

  for(const raw of lines){
    if(!raw) continue;
    let line = raw.replace(/^\s*data\s*:\s?/, '');
    if(!line) continue;

    if(line[0]==='{' || line[0]==='['){
      try{
        const obj=JSON.parse(line);
        if(obj.type==='begin' || obj.type==='end') continue;

        if(!img && obj.image_url) img = obj.image_url;
        if(!vid && obj.video_url) vid = obj.video_url;

        if(obj.pending && obj.op_name && !pending){
          pending=true; op_name=obj.op_name;
        }

        const chunk = (typeof obj.delta==='string' && obj.delta)
                   || (typeof obj.content==='string' && obj.content)
                   || (typeof obj.output==='string' && obj.output)
                   || (obj.item && typeof obj.item.content==='string' && obj.item.content)
                   || (obj.data && typeof obj.data.text==='string' && obj.data.text)
                   || (typeof obj.text==='string' && obj.text)
                   || '';
        if(chunk) acc+=chunk;
        continue;
      }catch{}
    }
    acc += line + '\n';
  }

  if(targetNode){
    if(markThought) setStatusChip(targetNode,'thought');
    targetNode.querySelector('.content').innerHTML=renderMarkdown(acc||'');

    if(img){
      const w=document.createElement('div'); w.className='content';
      w.innerHTML=`<a href="${encodeURI(img)}" target="_blank" rel="noopener"><img src="${encodeURI(img)}" alt="Image from AI"></a>`;
      chatEl.appendChild(w);
    }
    if(vid){
      const v=document.createElement('div'); v.className='content';
      const type = /\.webm$/i.test(vid) ? 'video/webm' : 'video/mp4';
      v.innerHTML=`<video controls playsinline><source src="${encodeURI(vid)}" type="${type}"></video>`;
      chatEl.appendChild(v);
    }

    if(pending && op_name){
      const typing=document.createElement('div');
      typing.className='content typing';
      typing.textContent='Generating video‚Ä¶';
      targetNode.after(typing);
      pollVideoUntilReady(op_name, (videoUrl, err)=>{
        typing.remove();
        if(err || !videoUrl){
          const eDiv=document.createElement('div'); eDiv.className='content'; eDiv.style.color='#b91c1c';
          eDiv.textContent='Video failed. Please try again.';
          chatEl.appendChild(eDiv);
          return;
        }
        const v=document.createElement('div'); v.className='content';
        const type = /\.webm$/i.test(videoUrl) ? 'video/webm' : 'video/mp4';
        v.innerHTML=`<video controls playsinline><source src="${encodeURI(videoUrl)}" type="${type}"></video>`;
        chatEl.appendChild(v);
      });
    }
  }

  return {content:acc, image_url:img, video_url:vid, pending, op_name};
}

/* Scroll-to-bottom button */
(function(){
  const chatBox=document.getElementById('chat');
  const scrollBtn=document.getElementById('scrollBtn');
  function toggleBtn(){
    const threshold=200;
    if (chatBox.scrollHeight - chatBox.scrollTop > chatBox.clientHeight + threshold) {
      scrollBtn.classList.add('show');
    } else {
      scrollBtn.classList.remove('show');
    }
  }
  chatBox.addEventListener('scroll',toggleBtn);
  scrollBtn.addEventListener('click',()=>{chatBox.scrollTop=chatBox.scrollHeight;});
  toggleBtn();
})();
</script>
</body>
</html>
